<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COYOTE - コヨーテ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes zoom-in {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .animate-zoom-in { animation: zoom-in 0.5s ease-out; }
    </style>
</head>
<body class="bg-slate-950">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 設定のダミー (Firebaseを使わない場合のエラー回避用) ---
        const __firebase_config = '{"apiKey":"dummy"}';
        const __app_id = 'default';

        // --- アイコンコンポーネント (SVGで代用) ---
        const Icon = ({ name }) => {
            const icons = {
                moon: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>,
                cpu: <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 8h10"/><path d="M7 12h10"/><path d="M7 16h10"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M1 12h2"/><path d="M21 12h2"/></svg>,
                users: <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
                trophy: <svg xmlns="http://www.w3.org/2000/svg" width="180" height="180" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
            };
            return icons[name] || null;
        };

        // --- ゲームロジック用定数 ---
        const CARD_TYPES = { NUMBER: 'number', CAVALRY: 'cavalry', NIGHT: 'night', CHIEF: 'chief', FOX: 'fox', CAVE: 'cave' };

        const GET_FULL_DECK = () => {
            const cards = [];
            [1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 10, 10, 10, 15, 15, 20, 0, 0, 0].forEach(v => cards.push({ value: v, type: CARD_TYPES.NUMBER, label: v.toString() }));
            cards.push({ value: -5, type: CARD_TYPES.CAVALRY, label: '-5' }, { value: -5, type: CARD_TYPES.CAVALRY, label: '-5' }, { value: -10, type: CARD_TYPES.CAVALRY, label: '-10' });
            cards.push({ value: 0, type: CARD_TYPES.NIGHT, label: 'シャッフル 0' }, { value: 0, type: CARD_TYPES.CHIEF, label: '×2' }, { value: 0, type: CARD_TYPES.FOX, label: 'MAX→0' }, { value: 0, type: CARD_TYPES.CAVE, label: '?' });
            return cards.map((c, i) => ({ ...c, id: `card-${i}-${Math.random()}` }));
        };

        const shuffle = (array) => [...array].sort(() => Math.random() - 0.5);

        const calculateTotal = (visibleCards, deck) => {
            let steps = [];
            let currentCards = [...visibleCards];
            let remainingDeck = [...deck];
            if (currentCards.some(c => c.type === CARD_TYPES.CAVE) && remainingDeck.length > 0) {
                const caveCard = remainingDeck.shift();
                currentCards.push(caveCard);
                steps.push(`ほらあな(?): ${caveCard.label} を追加`);
            }
            if (currentCards.some(c => c.type === CARD_TYPES.FOX)) {
                let maxVal = -999, targetIdx = -1;
                currentCards.forEach((c, i) => {
                    const val = (c.type === CARD_TYPES.NUMBER || c.type === CARD_TYPES.CAVALRY) ? c.value : 0;
                    if (val > maxVal) { maxVal = val; targetIdx = i; }
                });
                if (targetIdx !== -1) {
                    steps.push(`キツネ: ${currentCards[targetIdx].label} を 0 化`);
                    currentCards[targetIdx] = { ...currentCards[targetIdx], value: 0 };
                }
            }
            let sum = currentCards.reduce((s, c) => s + (c.value || 0), 0);
            steps.push(`基本合計: ${sum}`);
            if (currentCards.some(c => c.type === CARD_TYPES.CHIEF)) { sum *= 2; steps.push(`酋長: 2倍で ${sum}`); }
            return { total: sum, steps, nightExists: currentCards.some(c => c.type === CARD_TYPES.NIGHT), remainingDeck };
        };

        // --- UI部品 ---
        const DrumRollSelector = ({ minVal, maxVal, onSelect }) => {
            const scrollRef = useRef(null);
            const options = Array.from({ length: maxVal - minVal + 1 }, (_, i) => minVal + i);
            const [active, setActive] = useState(0);

            const handleScroll = () => {
                const idx = Math.round(scrollRef.current.scrollTop / 64);
                if (options[idx]) { setActive(idx); onSelect(options[idx]); }
            };

            return (
                <div className="relative w-40 h-[320px] bg-slate-900 rounded-[32px] overflow-hidden border-4 border-indigo-500/30">
                    <div className="absolute top-1/2 left-0 right-0 h-16 -translate-y-1/2 bg-indigo-500/20 border-y-2 border-indigo-500/50 pointer-events-none z-10" />
                    <div onScroll={handleScroll} ref={scrollRef} className="w-full h-full overflow-y-scroll no-scrollbar snap-y snap-mandatory p-2">
                        <div className="h-32" />
                        {options.map((v, i) => (
                            <div key={v} className={`h-16 flex items-center justify-center text-4xl font-black snap-center ${i === active ? 'text-white scale-110' : 'text-slate-700'}`}>{v}</div>
                        ))}
                        <div className="h-32" />
                    </div>
                </div>
            );
        };

        const Card = ({ card, isHidden }) => {
            if (!card) return <div className="w-20 h-28 bg-slate-800 rounded-2xl border-2 border-dashed border-slate-700"></div>;
            const color = isHidden ? 'bg-indigo-600' : (card.type === CARD_TYPES.NUMBER ? 'bg-white' : 'bg-rose-100');
            return (
                <div className={`w-20 h-28 md:w-24 md:h-36 rounded-2xl flex flex-col items-center justify-center border-4 shadow-xl ${color}`}>
                    {isHidden ? <span className="text-4xl font-black text-white">?</span> : 
                    <span className="text-3xl font-black text-slate-900">{card.label}</span>}
                </div>
            );
        };

        // --- メインアプリ ---
        function CoyoteApp() {
            const [view, setView] = useState('home');
            const [gameState, setGameState] = useState(null);
            const [playerCount, setPlayerCount] = useState(3);
            const [selectedDec, setSelectedDec] = useState(1);

            const startLocalGame = () => {
                let deck = shuffle(GET_FULL_DECK());
                const players = Array.from({ length: playerCount }, (_, i) => ({
                    uid: `p-${i}`, name: i === 0 ? 'You' : `CPU ${i}`, lives: 3, card: deck.pop()
                }));
                setGameState({ status: 'playing', players, deck, discardPile: [], currentTurnIndex: 0, currentDeclaration: 0 });
                setView('game');
            };

            const handleDeclare = (val) => {
                let next = (gameState.currentTurnIndex + 1) % gameState.players.length;
                while(gameState.players[next].lives <= 0) next = (next + 1) % gameState.players.length;
                setGameState({ ...gameState, currentDeclaration: val, currentTurnIndex: next });
            };

            const handleCoyote = () => {
                const { total, steps, nightExists, remainingDeck } = calculateTotal(gameState.players.filter(p => p.lives > 0).map(p => p.card), gameState.deck);
                const dec = gameState.currentDeclaration;
                let prev = (gameState.currentTurnIndex - 1 + gameState.players.length) % gameState.players.length;
                while(gameState.players[prev].lives <= 0) prev = (prev - 1 + gameState.players.length) % gameState.players.length;
                
                const loserIdx = dec > total ? prev : gameState.currentTurnIndex;
                const newPlayers = [...gameState.players];
                newPlayers[loserIdx].lives -= 1;

                setGameState({ ...gameState, status: 'result', players: newPlayers, resultData: { total, message: dec > total ? '大成功！' : 'ドボン！', steps } });
            };

            const nextRound = () => {
                const alive = gameState.players.filter(p => p.lives > 0);
                if (alive.length === 1) { setGameState({ ...gameState, status: 'winner', winner: alive[0] }); return; }
                
                let deck = shuffle(GET_FULL_DECK());
                const newPlayers = gameState.players.map(p => p.lives > 0 ? { ...p, card: deck.pop() } : p);
                setGameState({ ...gameState, status: 'playing', players: newPlayers, deck, currentDeclaration: 0, currentTurnIndex: 0 });
            };

            return (
                <div className="min-h-screen text-slate-200 p-4">
                    <header className="flex justify-between items-center max-w-4xl mx-auto mb-10">
                        <div className="flex items-center gap-2">
                            <div className="bg-indigo-600 p-2 rounded-lg"><Icon name="moon" /></div>
                            <h1 className="text-2xl font-black italic">COYOTE</h1>
                        </div>
                        {view !== 'home' && <button onClick={() => setView('home')} className="bg-slate-800 px-4 py-1 rounded-full text-sm">EXIT</button>}
                    </header>

                    {view === 'home' ? (
                        <div className="flex flex-col items-center gap-8 animate-zoom-in">
                            <div className="bg-slate-900 p-8 rounded-[40px] text-center w-full max-w-md">
                                <div className="text-indigo-400 text-xs font-black mb-4">PLAYERS</div>
                                <div className="flex items-center justify-center gap-6">
                                    <button onClick={() => setPlayerCount(Math.max(2, playerCount-1))} className="text-4xl">-</button>
                                    <span className="text-7xl font-black">{playerCount}</span>
                                    <button onClick={() => setPlayerCount(Math.min(6, playerCount+1))} className="text-4xl">+</button>
                                </div>
                            </div>
                            <button onClick={startLocalGame} className="bg-emerald-600 p-6 rounded-3xl w-full max-w-md text-2xl font-black flex items-center justify-center gap-4">
                                <Icon name="cpu" /> CPU対戦スタート
                            </button>
                        </div>
                    ) : (
                        <div className="max-w-4xl mx-auto space-y-10">
                            <div className="flex flex-wrap justify-center gap-4">
                                {gameState.players.map((p, i) => (
                                    <div key={i} className={`p-4 rounded-2xl border-2 ${i === gameState.currentTurnIndex ? 'border-indigo-500 bg-indigo-500/10' : 'border-slate-800'} ${p.lives <= 0 ? 'opacity-30' : ''}`}>
                                        <div className="text-xs mb-2">{p.name}</div>
                                        <Card card={p.card} isHidden={i === 0 && gameState.status === 'playing'} />
                                        <div className="flex gap-1 mt-2">
                                            {[...Array(p.lives)].map((_, li) => <div key={li} className="w-2 h-2 bg-rose-500 rounded-full" />)}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {gameState.status === 'playing' ? (
                                <div className="bg-slate-900 p-8 rounded-[40px] flex flex-col md:flex-row items-center gap-8">
                                    <DrumRollSelector minVal={gameState.currentDeclaration + 1} maxVal={100} onSelect={setSelectedDec} />
                                    <div className="flex-1 w-full text-center space-y-6">
                                        <div>
                                            <div className="text-xs text-slate-500">現在の宣言</div>
                                            <div className="text-6xl font-black">{gameState.currentDeclaration}</div>
                                        </div>
                                        <button onClick={() => handleDeclare(selectedDec)} className="w-full bg-indigo-600 p-6 rounded-2xl text-2xl font-black">{selectedDec} を宣言！</button>
                                        <button onClick={handleCoyote} className="w-full border-2 border-rose-500 text-rose-500 p-3 rounded-2xl font-bold">コヨーテ！</button>
                                    </div>
                                </div>
                            ) : gameState.status === 'result' ? (
                                <div className="bg-white text-slate-900 p-8 rounded-[40px] text-center animate-zoom-in">
                                    <div className="text-4xl font-black mb-2">{gameState.resultData.message}</div>
                                    <div className="text-xs text-slate-500">実際の合計値</div>
                                    <div className="text-8xl font-black mb-6">{gameState.resultData.total}</div>
                                    <button onClick={nextRound} className="w-full bg-slate-900 text-white p-5 rounded-2xl font-black">次のラウンドへ</button>
                                </div>
                            ) : gameState.status === 'winner' ? (
                                <div className="text-center py-20 animate-zoom-in">
                                    <Icon name="trophy" />
                                    <div className="text-5xl font-black mt-6">{gameState.winner.name} の優勝！</div>
                                    <button onClick={() => setView('home')} className="mt-10 bg-indigo-600 px-10 py-4 rounded-full font-black">トップに戻る</button>
                                </div>
                            ) : null}
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CoyoteApp />);
    </script>
</body>
</html>
